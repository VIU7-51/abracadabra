
#include <iostream>
#include <locale>
#include <iomanip>
//#include <cassert>
#include <string>

using namespace std;

/*
* StackElement - элемент нашего стэка, ячейка, хранящая значение и адрес следующего элемента.
*/
class StackElement {
public:
	StackElement* prev;     // Указатель на предыдущий элемент стэка. Если это первый элемент в 
							// стэке, то значение будет NULL
	int value;              // Значение этого элемента

	StackElement(StackElement *, int);  // Конструктор элемента, на вход принимает указатель на предыдущий
										// элемент и значение, которое нужно поместить в элемент
};

StackElement::StackElement(StackElement *p, int v) {
	prev = p;       // В это поле элемента пишем адрес предыдущего элемента
	value = v;      // В это поле пишем число, которое нужно хранить
}

/*
* IntStack - обёртка, хранилище всех объектов StackElement. Оно не хранит их внутри себя, только
* адрес последнего добавленного элемента. Все остальные элементы "вытягиваются" по цепочке currentElement -
* - StackElement->prev - StackElement->prev... и так, пока у одного из элементов prev не будет равен NULL,
* что значит, что мы дошли до "дна" стэка.
*/
class IntStack {
public:
	StackElement *currentElement;   // Указатель на последний добавленный элемент
	int length;         // Текущее количество элементов в стэке

	IntStack();         // Конструктор
	void push(int);     // Поместить элемент в стек
	int pop();          // Удалить из стека элемена
	void printStack();  // Печатает все элементы стэка
};

/*
* Конструктор
*/
IntStack::IntStack() {
	length = 0;             // Устанавливаем начальную длину стэка в 0
	currentElement = NULL;  // В пустом стэке адрес последнего элемента будет отсуствовать (NULL)
}

/*
* Помещаем элемент в стэк.
* Функции нужно знать только помещаемое значение, т.к. вся остальная информация есть у
* экземпляра класса, членом которой является эта функция. В этом и назначение данной "обертки".
*/
void IntStack::push(int value) {
	// Выделяем память через new и создаем элемент конструктором
	// Конструктору передаем входное значение value и адрес текущего последнего элемента
	StackElement* newElement = new StackElement(this->currentElement, value);
	// this значит "этот экземпляр класса". В данном случае это можно представить как 
	// "возьми у себя значение currentElement"

	this->currentElement = newElement;  // Помещаем в currentElement адрес нового элемента
										// Адрес предыдущего элемента переместился из currentElement в newElement->prev
										// на этапе конструирования несколькиими строчками выше

	this->length++;                     // Увеличиваем счетчик элементов
}

/*
* Выбирает последний добавленный в стэк элемент StackElement. Удаляет его из стэка и возвращает значнение
* value этого элемента
*/
int IntStack::pop() {
	if (this->length != 0) {            //Проверяем количество элементов в стэке. Если 0, то ничего делать не нужно.
		StackElement* element = this->currentElement;
		// По адресу, хранящемуся в обертке, находим последний добавленный
		// элемент стэка и сохраняем его в локальную переменную element

		int value = element->value;  // Берем значение value этого элемента
		this->currentElement = element->prev;
		// Т.к. мы удаляем последний добавленный элемент из стэка, то currentElement 
		// в обертке должен указывать на предпоследний элемент, адрес которого мы можем узнать 
		// из поля prev удаляемого элемента

		delete element;          // Т.к. в C++ не предусмотрен автоматический сборщик мусора, то нужно явно
		// освободить память, занимаемую удаляемым элементом.
		// не уверен пока насчет этой строки, проверю, когда доберусь до компа со студией
		length--;                   // Уменьшаем счетчик количества элементов в стэке
		return value;               // Возвращаем значение удаляемого элемента
	}
	else {
		return NULL;
	}
}

/*
* Печатаем все значения элементов стэка
*/
void IntStack::printStack() {

	if (length == 0) {                // Если длина стэка 0, то ничего выводить не нужно
		cout << "Пусто" << endl;
		return;                     // Выходим из фунцкии тут
	}

	//Если длина не 0, то начинаем выводить элементы
	StackElement* elementPtr = this->currentElement;    // Берем последний добавленный элемент по адресу currentElement

	while (elementPtr) {             // Пока указатель не NULL, цикл будет продолжаться
									 // NULL там появится, когда мы достигнем последнего элемента в стэке
		StackElement element = *elementPtr;             // Берем элемент стэка
		cout << "|" << setw(4) << element.value;        // Выводим значение этого элемента
		elementPtr = element.prev;                      // Переводим указатель на следующий элемент стэка
														// Если текущий элемент - последний, то в elementPtr окажется NULL
	}

	cout << endl;                   // Переводим на новую строку для красоты.
}

int main() {
	setlocale(LC_ALL, "");          // Задаем локаль, чтобы кириллица выводилась на экран правильно
	string command;                 // Переменная для хранения введенной команды
	IntStack myStack;               // Создаем нашу обертку для стэка

									// Так выглядит наше меню с возможными командами
	cout << "Помещаем элементы в стек. Вывод стека: 'print', взять элемент: 'pop', выход: 'quit'. " << endl;
	cin >> command;             // Считываем первую команду 

	while (command != "quit") {     // Пока не ввели quit, продолжаем считывать команды
		
		if (command == "print") {   // Получена команда на печать стэка
			myStack.printStack();
		}
		else if (command == "pop") {      // Получена команда на удаление последнего элемента стэка
			cout << myStack.pop() << endl;  // Выводим значение удаляемого элемента на экран
		}
		else {                    // Если ни одно из условий выше не выполнилось, значит ввели значение нового элемента
			myStack.push(std::stoi(command));   // Записываем новый элемент в стэк. При этом нужно сконвертировать
												// значение из типа string в int с помощью stoi
			// Здесь небезопасно, т.к. если ввести что-то не из этих команд или числа, программа вылетит.
			// Нужно обрабатывать исключения если не удалось строку преобразовать в число, например если ввели "12abc"
		}

		cin >> command;             // Считываем следующую команду 
	}

	system("pause");

	return 0;
}
